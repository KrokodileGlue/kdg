#!/usr/bin/env perl
# SPDX-License-Identifier: MIT

# This script generates `unicode_data.c' from the following files:
#
#     - UnicodeData.txt
#     - SpecialCasing.txt
#     - DerivedCoreProperties.txt
#     - GraphemeBreakProperty.txt
#     - CompositionExclusions.txt
#     - CaseFolding.txt
#
# Don't run this script directly if you're generating the file for the
# first time. Instead, run `./gen.sh' in this directory and all of the
# relevant Unicode Data Files will be downloaded automatically and
# unicode_data.c will be copied to src/. The Unicode Data Files are
# licensed under the Unicode Data License; see LICENSE.md for details.

use strict;
use warnings;
use v5.10;
use lib '.';

use Getopt::Long;
use Char;

# Global configuration variables.
my $blocksize = 4000;
my $filename  = "unicode_data.c";
my $verbose   = 0;

GetOptions("length=i" => \$blocksize,
           "output=s" => \$filename,
           "verbose"  => \$verbose)
  or die("gen.pl: Exiting due to invalid " .
         "command-line parameters.\n");

if ($verbose) {
	print "gen.pl: Running with verbose output.\n";
	print "gen.pl: Dumping output into `$filename'.\n";
}

# <DATA> contains the hand-maintained includes/comments for the file.
open(my $out, ">", $filename);
print $out <DATA>, "\n";
print $out "struct codepoint codepoints[] = {\n";

open(my $fh, '<:encoding(UTF-8)', "UnicodeData.txt")
  or die "gen.pl: Could not open `UnicodeData.txt': $!\n";

# Build a hash table of code points.
my %chars;
while (my $l = <$fh>) {
	chomp $l;

	# It's not a range, it's just a regular character.
	if ($l !~ /^([0-9A-F]+);<[^;>,]+, First>;/i) {
		$l =~ /^(.*?);/;
		$chars{$1} = Char->new(line => $l);
		$chars{$1}->echo(0);
		next;
	}

	# It's a range!
	$l = <$fh>;
	die "gen.pl: Expected range end-point at line: $l\n"
	  if $l !~ /^([0-9A-F]+);<([^;>,]+), Last>;/i;
}

print $out "};\n\n";
print "gen.pl: Loaded ", scalar keys %chars, " code points.\n"
  if $verbose;

# Now it's time to generate the trie lookup table. A basic explanation
# of this system is here:
# http://site.icu-project.org/design/struct/utrie

# We use a 2-stage table, not counting the data table itself.
#
# Thinking about how the process works can be a bit confusing, so a
# practical example of a lookup may be helpful:
#
#     1. Begin with U+61 --- block 0
#     2. Look up 0 in stage1 --- index 0
#     3. Look up 0x0061 (the bottom two byes of the original code
#        point) in the first table in stage2 -- index 12
#     4. Read the 12th entry
#
# Reading the 12th entry yields a struct with indices for various data
# elements in other tables.

# I found https://goo.gl/9kKWzH very useful.

my $SHIFT_1                    = 6 + 5;
my $SHIFT_2                    = 5;
my $SHIFT_1_2                  = $SHIFT_1 - $SHIFT_2;
my $OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> $SHIFT_1;
my $CP_PER_INDEX_1_ENTRY       = 1 << $SHIFT_1;
my $INDEX_2_BLOCK_LENGTH       = 1 << $SHIFT_1_2;
my $INDEX_2_MASK               = $INDEX_2_BLOCK_LENGTH - 1;
my $DATA_BLOCK_LENGTH          = 1 << $SHIFT_2;
my $DATA_MASK                  = $DATA_BLOCK_LENGTH - 1;

my @stage1;

print $out "uint16_t stage1[] = {\n";
print $out "}\n";

__DATA__
// SPDX-License-Identifier: Unicode-DFS-2016

/*
 * This file is generated by `script/gen.pl'; do not edit by hand.
 */

#include "kdgu.h"
#include "unicode_data.h"
